import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import html2canvas from 'html2canvas';
import { type Project, type AnalysisData } from '@shared/schema';

// Extend jsPDF type for autotable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface PDFExportOptions {
  project: Project;
  analysisData: AnalysisData;
  includeAllDiagrams?: boolean;
}

export class PDFExportService {
  private doc: jsPDF;
  private pageHeight: number;
  private pageWidth: number;
  private currentY: number;
  private margin: number;
  private lineHeight: number;

  constructor() {
    this.doc = new jsPDF('p', 'mm', 'a4');
    this.pageHeight = this.doc.internal.pageSize.height;
    this.pageWidth = this.doc.internal.pageSize.width;
    this.margin = 20;
    this.currentY = this.margin;
    this.lineHeight = 7;
  }

  async exportProjectAnalysis(options: PDFExportOptions): Promise<void> {
    const { project, analysisData } = options;
    const aiInsights = analysisData.aiAnalysis;
    const projectDetails = aiInsights?.projectDetails;

    // Cover Page
    this.createCoverPage(project);
    
    // Table of Contents
    this.addNewPage();
    this.createTableOfContents();
    
    // Project Overview
    this.addNewPage();
    this.addSection('1. Project Overview', () => {
      this.addProjectOverview(project, analysisData);
    });

    // Project Details
    if (projectDetails) {
      this.addSection('2. Project Analysis Details', () => {
        this.addProjectDetails(projectDetails);
      });
    }

    // Architecture Analysis
    this.addSection('3. Architecture Analysis', () => {
      this.addArchitectureAnalysis(analysisData);
    });

    // Code Structure
    this.addSection('4. Code Structure', () => {
      this.addCodeStructure(analysisData);
    });

    // AI Insights
    if (aiInsights) {
      this.addSection('5. AI-Powered Insights', () => {
        this.addAIInsights(aiInsights);
      });
    }

    // Diagrams Section
    this.addSection('6. Architecture Diagrams', () => {
      this.addText('The following diagrams provide visual representations of the project architecture:');
      this.addSpace(10);
    });

    // Export diagrams
    await this.exportDiagrams(['flow', 'component', 'class', 'sequence', 'er']);

    // Add headers and footers to all pages
    this.finalizeDocument();

    // Save the PDF
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
    this.doc.save(`${project.name}-analysis-${timestamp}.pdf`);
  }

  private addHeaderFooter(): void {
    // Note: Headers and footers will be added after all pages are created
    // This is called at the end of the export process
  }

  private createCoverPage(project: Project): void {
    this.currentY = 60;
    
    // Title
    this.doc.setFontSize(28);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text('Project Analysis Report', this.pageWidth / 2, this.currentY, { align: 'center' });
    
    this.currentY += 20;
    this.doc.setFontSize(20);
    this.doc.setTextColor(50, 50, 50);
    this.doc.text(project.name, this.pageWidth / 2, this.currentY, { align: 'center' });
    
    this.currentY += 40;
    
    // Project info box
    this.doc.setFillColor(245, 245, 245);
    this.doc.rect(this.margin, this.currentY, this.pageWidth - 2 * this.margin, 60, 'F');
    
    this.currentY += 15;
    this.doc.setFontSize(12);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text('Generated by:', this.margin + 10, this.currentY);
    this.doc.text('Zengent AI Architecture Analyzer', this.margin + 50, this.currentY);
    
    this.currentY += 10;
    this.doc.text('Date:', this.margin + 10, this.currentY);
    this.doc.text(new Date().toLocaleDateString(), this.margin + 50, this.currentY);
    
    this.currentY += 10;
    this.doc.text('Analysis Type:', this.margin + 10, this.currentY);
    this.doc.text('Multi-Language Code Analysis', this.margin + 50, this.currentY);
  }

  private createTableOfContents(): void {
    this.addTitle('Table of Contents');
    this.addSpace(10);
    
    const contents = [
      '1. Project Overview ............................................................... 3',
      '2. Project Analysis Details .................................................... 4',
      '3. Architecture Analysis ....................................................... 5',
      '4. Code Structure ............................................................... 6',
      '5. AI-Powered Insights ......................................................... 7',
      '6. Architecture Diagrams ....................................................... 8'
    ];
    
    contents.forEach(item => {
      this.addText(item);
      this.addSpace(5);
    });
  }

  private addProjectOverview(project: Project, analysisData: AnalysisData): void {
    this.addSubtitle('Project Summary');
    this.addText(`Project Name: ${project.name}`);
    this.addText(`Analysis Date: ${new Date().toLocaleDateString()}`);
    this.addText(`Files Analyzed: ${analysisData.structure.sourceFiles.length}`);
    this.addSpace(10);
    
    // Statistics
    const controllers = analysisData.classes.filter(c => c.type === 'controller');
    const services = analysisData.classes.filter(c => c.type === 'service');
    const repositories = analysisData.classes.filter(c => c.type === 'repository');
    const entities = analysisData.classes.filter(c => c.type === 'entity');
    
    this.addSubtitle('Project Statistics');
    this.addText(`• Controllers: ${controllers.length}`);
    this.addText(`• Services: ${services.length}`);
    this.addText(`• Repositories: ${repositories.length}`);
    this.addText(`• Entities: ${entities.length}`);
    this.addText(`• Total Classes: ${analysisData.classes.length}`);
    this.addText(`• Relationships: ${analysisData.relationships.length}`);
  }

  private addProjectDetails(projectDetails: any): void {
    this.addSubtitle('Project Description');
    this.addWrappedText(projectDetails.projectDescription);
    this.addSpace(10);
    
    this.addSubtitle('Business Problem Addressed');
    this.addWrappedText(projectDetails.businessProblem);
    this.addSpace(10);
    
    this.addSubtitle('Key Objective');
    this.addWrappedText(projectDetails.keyObjective);
    this.addSpace(10);
    
    this.addSubtitle('Summary of Functionality');
    this.addWrappedText(projectDetails.functionalitySummary);
    this.addSpace(10);
    
    this.addSubtitle('Implemented Features');
    projectDetails.implementedFeatures.forEach((feature: string) => {
      this.addText(`• ${feature}`);
    });
    this.addSpace(10);
    
    this.addSubtitle('Modules and Services');
    projectDetails.modulesServices.forEach((module: string) => {
      this.addText(`• ${module}`);
    });
  }

  private addArchitectureAnalysis(analysisData: AnalysisData): void {
    this.addSubtitle('Architecture Patterns');
    
    const hasControllers = analysisData.classes.some(c => c.type === 'controller');
    const hasServices = analysisData.classes.some(c => c.type === 'service');
    const hasRepositories = analysisData.classes.some(c => c.type === 'repository');
    
    if (hasControllers && hasServices && hasRepositories) {
      this.addText('✓ Layered Architecture Pattern Detected');
      this.addText('✓ Separation of Concerns Implemented');
    }
    
    const springAnnotations = analysisData.classes.filter(c => 
      c.annotations.some(a => a.includes('@Controller') || a.includes('@Service') || a.includes('@Repository'))
    );
    
    if (springAnnotations.length > 0) {
      this.addText('✓ Spring Framework Annotations Used');
      this.addText('✓ Dependency Injection Pattern');
    }
    
    this.addSpace(10);
    
    this.addSubtitle('Quality Metrics');
    const qualityScore = analysisData.aiAnalysis?.qualityScore || 0;
    this.addText(`Overall Quality Score: ${qualityScore}/100`);
    
    if (qualityScore >= 80) {
      this.addText('• Excellent code organization and architecture');
    } else if (qualityScore >= 60) {
      this.addText('• Good code structure with room for improvement');
    } else {
      this.addText('• Consider refactoring for better architecture');
    }
  }

  private addCodeStructure(analysisData: AnalysisData): void {
    this.addSubtitle('Package Structure');
    
    const packages = new Set<string>();
    analysisData.classes.forEach(cls => {
      packages.add(cls.package);
    });
    
    Array.from(packages).sort().forEach(pkg => {
      this.addText(`• ${pkg}`);
    });
    
    this.addSpace(10);
    
    this.addSubtitle('Class Distribution by Type');
    const classTypes = ['controller', 'service', 'repository', 'entity', 'component', 'configuration'];
    
    classTypes.forEach(type => {
      const count = analysisData.classes.filter(c => c.type === type).length;
      if (count > 0) {
        this.addText(`• ${type.charAt(0).toUpperCase() + type.slice(1)}: ${count} classes`);
      }
    });
  }

  private addAIInsights(aiInsights: any): void {
    this.addSubtitle('Project Overview');
    if (aiInsights.projectOverview) {
      this.addWrappedText(aiInsights.projectOverview);
    }
    
    this.addSpace(10);
    
    this.addSubtitle('Architecture Recommendations');
    if (aiInsights.suggestions && aiInsights.suggestions.length > 0) {
      aiInsights.suggestions.forEach((suggestion: string) => {
        this.addText(`• ${suggestion}`);
      });
    }
    
    this.addSpace(10);
    
    if (aiInsights.architectureInsights && aiInsights.architectureInsights.length > 0) {
      this.addSubtitle('Technical Insights');
      aiInsights.architectureInsights.forEach((insight: string) => {
        this.addText(`• ${insight}`);
      });
    }
  }

  private async exportDiagrams(diagramTypes: string[]): Promise<void> {
    for (const type of diagramTypes) {
      await this.captureDiagram(type);
    }
  }

  private async captureDiagram(type: string): Promise<void> {
    try {
      // Trigger diagram type change
      const tabTrigger = document.querySelector(`[value="${type}"]`) as HTMLElement;
      if (tabTrigger) {
        tabTrigger.click();
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for diagram to render
      }

      const diagramElement = document.querySelector('.react-flow') as HTMLElement;
      if (diagramElement) {
        const canvas = await html2canvas(diagramElement, {
          backgroundColor: '#ffffff',
          scale: 1,
          width: 800,
          height: 600
        });

        this.addNewPage();
        this.addSubtitle(`${type.charAt(0).toUpperCase() + type.slice(1)} Diagram`);
        this.addSpace(10);

        const imgData = canvas.toDataURL('image/jpeg', 0.8);
        const imgWidth = this.pageWidth - 2 * this.margin;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;

        if (this.currentY + imgHeight > this.pageHeight - this.margin) {
          this.addNewPage();
        }

        this.doc.addImage(imgData, 'JPEG', this.margin, this.currentY, imgWidth, imgHeight);
        this.currentY += imgHeight + 10;
      }
    } catch (error) {
      console.error(`Failed to capture ${type} diagram:`, error);
      this.addText(`${type} diagram could not be captured`);
    }
  }

  private addSection(title: string, content: () => void): void {
    this.addTitle(title);
    this.addSpace(10);
    content();
    this.addSpace(20);
  }

  private addTitle(text: string): void {
    this.doc.setFontSize(16);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight + 5;
  }

  private addSubtitle(text: string): void {
    this.doc.setFontSize(12);
    this.doc.setTextColor(50, 50, 50);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight;
  }

  private addText(text: string): void {
    this.doc.setFontSize(10);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight;
    
    if (this.currentY > this.pageHeight - this.margin - 20) {
      this.addNewPage();
    }
  }

  private addWrappedText(text: string): void {
    this.doc.setFontSize(10);
    this.doc.setTextColor(0, 0, 0);
    
    const maxWidth = this.pageWidth - 2 * this.margin;
    const lines = this.doc.splitTextToSize(text, maxWidth);
    
    lines.forEach((line: string) => {
      if (this.currentY > this.pageHeight - this.margin - 20) {
        this.addNewPage();
      }
      this.doc.text(line, this.margin, this.currentY);
      this.currentY += this.lineHeight;
    });
  }

  private addSpace(space: number): void {
    this.currentY += space;
    
    if (this.currentY > this.pageHeight - this.margin - 20) {
      this.addNewPage();
    }
  }

  private addNewPage(): void {
    this.doc.addPage();
    this.currentY = this.margin + 10;
  }

  private finalizeDocument(): void {
    const pageCount = this.doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      this.doc.setPage(i);
      
      // Header
      this.doc.setFontSize(10);
      this.doc.setTextColor(100, 100, 100);
      this.doc.text('Zengent - Multi-Language Architecture Analyzer', this.margin, 15);
      
      // Header line
      this.doc.setDrawColor(200, 200, 200);
      this.doc.line(this.margin, 18, this.pageWidth - this.margin, 18);
      
      // Footer
      this.doc.text(`Page ${i}`, this.pageWidth - this.margin - 15, this.pageHeight - 10);
      this.doc.text(new Date().toLocaleDateString(), this.margin, this.pageHeight - 10);
      
      // Footer line
      this.doc.line(this.margin, this.pageHeight - 15, this.pageWidth - this.margin, this.pageHeight - 15);
    }
  }
}

export const pdfExportService = new PDFExportService();